datasource db {
    provider = "postgresql"
    url      = "postgresql://postgres:postgres@localhost:5432/omo-data?schema=public"
}

generator client {
    provider = "prisma-client-js"
}

model Identity {
  // A IPNS link to the "indexEntryHash".
  identityId String @unique
  // SOURCED FROM JWT's "sub" CLAIM:
  // Users can have an email address associated with them instead of a public key.
  // This address is then used (just like the email address) to send a challenge to the
  // user to verify that the user has access to the emial address.
  emailAddress String?
  // Initially or if the user decides to give us access to his rootStore, this field will contain a privateKey
  // that allows access to the set of entries which the user encrypted with this PPK.
  indexEntryPrivateKey String?
  // Contains the public key counterpart for the "keyStorePrivateKey".
  indexEntryPublicKey String
  // Contains the fingerprint of the "keyStorePublicKey" (key-length + [space character] + base64 encoded SHA256 hash of the public key).
  indexEntryKeyFingerprint String
  // The "entryHash" that points to the index Entry for this user.
  // The index-Entry stores references (also "entryHashes") to other Entries in a dicitionary: {[name:string]:entryHash}.
  // This acts like an IPNS link as it maps a consistent unique id (identityId) to a moving target (the indexEntryHash).
  indexEntryHash String?

  // agents Agent[] @relation("IdentityAgents")
}

// "Entry" objects store public key encypted data.
// Owners can identify their Entries with the fingerprint of the public key they used to encrypt the content.
// Every entry can also be uniquely identified by it's "entryHash".
// The "entryHash" property contains an IPFS compatible hash of the concatenated values of creatorFingerPrint + ownerFingerPrint + content.
// -> Each Entry can have exactly one Owner as long as no private keys are shared.
// -> It must be assumed that entries cannot be deleted or modeified once they've been created.
model Entry {
  // The fingeprint of the creator's public key.
  creatorFingerPrint String
  // The fingerprint of the owner's public key.
  ownerFingerPrint String
  // A IPFS hash for the contents of this entry (creatorFingerPrint + ownerFingerPrint + content)
  entryHash String @unique
  // The actual data of that Entry (encrypted with the public key that's identified by the ownerFingerPrint).
  content String
}

// Authorities are trusted services that issue JWTs which this service accepts as authentication
model Authority {
  id Int @default(autoincrement()) @id
  issuer String
  appId String
}

model Session {
  // The session id is a unique random id.
  sessionId String @unique
  // Which Authoritity issued the JWT that lead to this session?
  issuedBy Authority
  // When the session was created.
  createdAt DateTime
  // Usually the session ends when the user closes the browser window/tab (session-cookie)
  // but there is also a fixed max. session length.
  // This fields specifies the max. session lifetime in seconds.
  maxLifetime Int
  // Who is identified by the session?
  identity Identity
}

//enum AgentType {
//  // Internally managed agent with private key (e.g. for e-mail challenge verification)
//  Internal
//  // A smartcard
//  Smartcard
//  // A desktop device
//  Desktop
//  // A mobile device
//  Device
//  // Other agents that can be used to recover an Identity.
//  // Recovery Agents cannot 'become' (act as) the linked identity but can only
//  // vote for key recovery to a new Agent.
//  Recovery
//}

// Eine Identity hat mehrere Agents, die in ihrem Namen handeln können.
// Jeder Agent soll die Identität einnehmen können.
//
// -> Die Identität muss alle validen Agents kennen
//    -> Agents werden anhand ihres public keys authentifiziert
//

// model Agent {
//    createdAt DateTime @default(now())
//    identity Identity  @relation("IdentityAgents", fields: [identityId], references: [identityId])
//    identityId String
//    name String @unique
//    type AgentType
//    publicKey String
//    publicKeyFingerprint String
//    privateKey String? // When "type == AgentType.Internal" then this field contains a private key.
//    config String?
//    disabledSince DateTime?
//
//    indexEntryHash String?
// }