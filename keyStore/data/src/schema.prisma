datasource db {
    provider = "postgresql"
    url      = "postgresql://postgres:postgres@localhost:5432/omo-keyStore?schema=public"
}

generator client {
    provider = "prisma-client-js"
}

// Authorities are trusted services that issue JWTs which this service accepts as authentication
model Authority {
  id Int @default(autoincrement()) @id
  issuer String
  appId String
}

// TODO: Check if Forward Secrecy can be used
// TODO: Are symetric cyphers a suitable solution for entity data encryption (leafs/blobs)
// TODO: when the sym. keys can be stored with asym. crypto?
// TODO: !! We should not take backups of this DB !! How to deal with that?
// -> One week rolling backups
// TODO: Describe how users can share access to keys.

// Basic Scenario:
// -------------------------------------
// 1) User signs up
// 2) We generate a PPK for the user and store it in an Identity object
// 3) The user now can create and read Entries via our service
// 4) The user decides to not like our service anymore
// 5) He/her exports his/her keys
// 6) He/her claims control over the "identityId" (IPNS)
// 7) He/her creates a new Identity document and points the IPNS link to the new document.

// Identity objects are only persisted on the OMO server. They are optional.
// The whole infrastructure should be usable without a central Identity.
// Everything except the "identityId" is mutable, so a User can e.g. switch from
// an email based authentication to a PPK based one.
// The indexEntryHash further changes on every update of the indexEntry.
// A client could provide the whole mechanism of this Identity on it's own.
model Identity {
  // A IPNS link to the "indexEntryHash".
  identityId String @unique
  // SOURCED FROM JWT's "sub" CLAIM:
  // Users can have an email address associated with them instead of a public key.
  // This address is then used (just like the email address) to send a challenge to the
  // user to verify that the user has access to the emial address.
  challengeEmailAddress String?
  // SOURCED FROM JWT's "sub" CLAIM:
  // Users can have a public key associated with them  instead of an email address.
  // This key is then used (just like the email address) to send a challenge to the
  // user to verify that the user is in possesion of the private key.
  challengePublicKey String?
  // Initially or if the user decides to give us access to his rootStore, this field will contain a privateKey
  // that allows access to the set of entries which the user encrypted with this PPK.
  indexEntryPrivateKey String?
  // Contains the public key counterpart for the "keyStorePrivateKey".
  indexEntryPublicKey String
  // Contains the fingerprint of the "keyStorePublicKey" (key-length + [space character] + base64 encoded SHA256 hash of the public key).
  indexEntryKeyFingerprint String
  // The "entryHash" that points to the index Entry for this user.
  // The index-Entry stores references (also "entryHashes") to other Entries in a dicitionary: {[name:string]:entryHash}.
  // This acts like an IPNS link as it maps a consistent unique id (identityId) to a moving target (the indexEntryHash).
  indexEntryHash String?
}

// "Entry" objects store public key encypted data.
// Owners can identify their Entries with the fingerprint of the public key they used to encrypt the content.
// Every entry can also be uniquely identified by it's "entryHash".
// The "entryHash" property contains an IPFS compatible hash of the concatenated values of "entryId", "ownerFingerPrint" and "content".
// -> Each Entry can have exactly one Owner as long as no private keys are shared.
// -> It must be assumed that entries cannot be deleted or modeified once they've been created.
model Entry {
  // A IPFS hash for the contents of this entry (nonce + ownerFingerPrint + content)
  entryHash String @unique
  // A (per Entry) unique random id. // TODO: It should be possible to create (non sensitive/public) Entries where the "nonce" shouldn't be included in the "entryHash". This would allow for a correct data deduplication. - Or not?
  nonce String
  // The fingerprint of the owner's public key.
  ownerFingerPrint String
  // The actual data of that Entry (encrypted with the public key that's identified by the ownerFingerPrint).
  content String
}

model Session {
  // A session is identified by the hash of the JWT that was exchanged for it +  a random nonce.
  // This will be sent via host-only cookie.
  sessionId String @unique


}