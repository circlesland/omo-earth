// This is your Prisma schema file,
// learn more about it in the docs https://pris.ly/d/prisma-schema

datasource db {
    provider = "postgresql"
    url      = "postgresql://postgres:postgres@localhost:5432/omo-keyStore?schema=public"
}
//
// 1) Ein neuer Nutzer meldet sich per E-Mail Adresse bei OMO an
// 2) Der "auth" Service schickt dem Nutzer eine E-Mail verification E-Mail
// 3) Der Nutzer bestätigt, dass er Zugriff auf die angegebene E-Mail Adresse hat
// 4) Der "auth" Service stellt dem Benutzer einen JWToken aus
// 5) Der Nutzer trägt diesen Token zum "pods" Service und tauscht ihn dort gegen
//    eine Session ein
// 6) Der "pods"-service erstellt einen neues Schlüsselpaar für das
//    Subjekt (sub-claim) des JWT
// 7) Der private-key wird mit der Session assoziiert
//
// * Alle Benutzer haben einen Keystore.
//   In diesem liegen alle seine Schlüssel.
// * Die Schlüssel werden mit einem Master-Schlüssel
//   entschlüsselt.
//   Der Master-Schlüssel ist erstmal in Besitz von OMO.
// * Benutzer können anderen Instanzen Zugriff auf ihren Keystore
//   gewähren, indem sie die Schlüssel abrufen und eine,
//   mit einem weiteren private-key verschlüsselte, Kopie
//   erstellen und wieder in ihrem Keystore ablegen.
//   Den weiteren key teilen sie dann mit der Instanz, die
//   Zugriff auf die Schlüssel möchte.
//
//
// * Es sollte möglich sein, dass Nutzer sich alternativ mit einem
//   PPK anmelden können. In diesem Fall wird eine Challenge
//   erstellt, die der Nutzer entschlüsselt zurücksenden muss
//   anstatt den E-Mail Link anzuklichen.
//   In diesem Fall kann ein Nutzer seine Daten zusätzlich
//   mit seinem (nur ihm bekannten) private key verschlüsseln.

generator client {
    provider = "prisma-client-js"
}

// Authorities are trusted services that issue JWTs which this service accepts as authentication
model Authority {
  id Int @default(autoincrement()) @id
  issuer String
  appId String
}

// TODO: Check if Forward Secrecy can be used

// TODO: Are symetric cyphers a suitable solution for entity data encryption (leafs/blobs)
// TODO: when the sym. keys kan be stored with asym. crypto?

// TODO: !! We should not take backups of this DB !! How to deal with that?
// -> One week rolling backups


// The KeyStore is made up from Entries.
// Every Entry is owned by someone who is identified by his/her public key fingerprint.
// The contents of each Entry are encrypted with the corresponding public key.
//    -> It's not possible to create a challenge from the Entry alone // TODO: Check if that's good or bad?
//
// The KeyStore should store keys to e.g. for a gnosis safe on etherium or to other stores
// on IPFS. A User can decrypt and retrieve the stored keys by creating a session at the KeyStore.
// With this session, the user can retrieve stored keys

// TODO: Describe how users can share access to keys.

// Basic Scenario:
// -------------------------------------
// 1) User signs up
// 2) We generate a PPK for the user and store it in an Identity object
// 3) The user now can create and read Entries via our service
// 4) The user decides to not like our service anymore
// 5) He/her exports his/her keys
// 6) He/her claims control over the "identityId" (IPNS)
// 7) He/her creates a new Identity document and points the IPNS link to the new document.

// Identity objects are only persisted on the OMO server. They are optional.
// The whole infrastructure should be usable without a central Identity.
// Everything except the "identityId" is mutable, so a User can e.g. switch from
// an email based authentication to a PPK based one.
// The indexEntryHash further changes on every update of the indexEntry.
// A client could provide the whole mechanism of this Identity on it's own.
model Identity {
  // A IPNS link to the "indexEntryHash".
  identityId String @unique
  // SOURCED FROM JWT's "sub" CLAIM:
  // Users can have an email address associated with them instead of a public key.
  // This address is then used (just like the email address) to send a challenge to the
  // user to verify that the user has access to the emial address.
  challengeEmailAddress String?
  // SOURCED FROM JWT's "sub" CLAIM:
  // Users can have a public key associated with them  instead of an email address.
  // This key is then used (just like the email address) to send a challenge to the
  // user to verify that the user is in possesion of the private key.
  challengePublicKey String?
  // Initially or if the user decides to give us access to his rootStore, this field will contain a privateKey
  // that allows access to the set of entries which the user encrypted with this key.
  indexEntryPrivateKey String
  // Contains the public key counterpart for the "keyStorePrivateKey".
  indexEntryPublicKey String
  // Contains the fingerprint of the "keyStorePublicKey" (key-length + [space character] + base64 encoded SHA256 hash of the public key).
  indexEntryKeyFingerprint String
  // The "entryHash" that points to the index Entry for this user.
  // The index-Entry stores references (also "entryHashes") to other Entries in a dicitionary: {[name:string]:entryHash}.
  // This acts like an IPNS link as it maps a consistent unique id (identityId) to a moving target (the indexEntryHash).
  indexEntryHash String?
}

// "Entry" objects store public key encypted data.
// Owners can identify their Entries with the fingerprint of the public key they used to encrypt the content.
// Every entry can also be uniquely identified by it's "entryHash".
// The "entryHash" property contains an IPFS compatible hash of the concatenated values of "entryId", "ownerFingerPrint" and "content".
// -> Each Entry can have exactly one Owner as long as no private keys are shared.
// -> It must be assumed that entries cannot be deleted or modeified once they've been created.
model Entry {
  // A IPFS hash for the contents of this entry (nonce + ownerFingerPrint + content)
  entryHash String @unique
  // A (per Entry) unique random id. // TODO: It should be possible to create (non sensitive/public) Entries where the "nonce" shouldn't be included in the "entryHash". This would allow for a correct data deduplication. - Or not?
  nonce String
  // The fingerprint of the owner's public key.
  ownerFingerPrint String
  // The actual data of that Entry (encrypted with the public key that's identified by the ownerFingerPrint).
  content String
}